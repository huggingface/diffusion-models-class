# Diffusion Models from Scratch

Sometimes it is helpful to consider the simplest possible version of something to better understand how it works. We're going to try that in this notebook, beginning with a 'toy' diffusion model to see how the different pieces work, and then examining how they differ from a more complex implementation. 

We will look at 
- The corruption process (adding noise to data)
- What a UNet is, and how to implement an extremely minimal one from scratch
- Diffusion model training
- Sampling theory

Then we'll compare our versions with the diffusers DDPM implementation, exploring
- Improvements over our mini UNet
- The DDPM noise schedule
- Differences in training objective
- Timestep conditioning
- Sampling approaches

This notebook is fairly in-depth, and can safely be skipped if you're not excited about a from-scratch deep dive! 

It is also worth noting that most of the code here is for illustrative purposes, and I wouldn't recommend directly adopting any of it for your own work (unless you're just trying improve on the examples shown here for learning purposes). 

## Setup and Imports:

```python
>>> %pip install -q diffusers
```

<pre>
[K     |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 255 kB 16.0 MB/s 
[K     |â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 163 kB 53.9 MB/s 
[?25h
</pre>

```python
>>> import torch
>>> import torchvision
>>> from torch import nn
>>> from torch.nn import functional as F
>>> from torch.utils.data import DataLoader
>>> from diffusers import DDPMScheduler, UNet2DModel
>>> from matplotlib import pyplot as plt

>>> device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
>>> print(f"Using device: {device}")
```

<pre>
Using device: cuda
</pre>

## The Data

Here we're going to test things with a very small dataset: mnist. If you'd like to give the model a slightly harder challenge without changing anything else, torchvision.datasets.FashionMNIST should work as a drop-in replacement. 

```python
>>> dataset = torchvision.datasets.MNIST(
...     root="mnist/", train=True, download=True, transform=torchvision.transforms.ToTensor()
... )
```

<pre>
Downloading http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz
Downloading http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz to mnist/MNIST/raw/train-images-idx3-ubyte.gz
</pre>

```python
train_dataloader = DataLoader(dataset, batch_size=8, shuffle=True)
```

```python
>>> x, y = next(iter(train_dataloader))
>>> print("Input shape:", x.shape)
>>> print("Labels:", y)
>>> plt.imshow(torchvision.utils.make_grid(x)[0], cmap="Greys")
```

<pre>
Input shape: torch.Size([8, 1, 28, 28])
Labels: tensor([1, 9, 7, 3, 5, 2, 1, 4])
</pre>

Each image is a greyscale 28px by 28px drawing of a digit, with values ranging from 0 to 1.

## The Corruption Process

Pretend you haven't read any diffusion model papers, but you know the process involves adding noise. How would you do it?

We probably want an easy way to control the amount of corruption. So what if we take in a parameter for the `amount` of noise to add, and then we do:

`noise = torch.rand_like(x)` 

`noisy_x =  (1-amount)*x + amount*noise`

If amount = 0, we get back the input without any changes. If amount gets up to 1, we get back noise with no trace of the input x. By mixing the input with noise this way, we keep the output in the same range (0 to 1).

We can implement this fairly easily (just watch the shapes so you don't get burnt by broadcasting rules): 

```python
def corrupt(x, amount):
    """Corrupt the input `x` by mixing it with noise according to `amount`"""
    noise = torch.rand_like(x)
    amount = amount.view(-1, 1, 1, 1)  # Sort shape so broadcasting works
    return x * (1 - amount) + noise * amount
```

And looking at the results visually to see that it works as expected:

```python
# Plotting the input data
fig, axs = plt.subplots(2, 1, figsize=(12, 5))
axs[0].set_title("Input data")
axs[0].imshow(torchvision.utils.make_grid(x)[0], cmap="Greys")

# Adding noise
amount = torch.linspace(0, 1, x.shape[0])  # Left to right -> more corruption
noised_x = corrupt(x, amount)

# Plotting the noised version
axs[1].set_title("Corrupted data (-- amount increases -->)")
axs[1].imshow(torchvision.utils.make_grid(noised_x)[0], cmap="Greys")
```

As noise amount approaches one, our data begins to look like pure random noise. But for most noise amounts, you can guess the digit fairly well. Do you think this is optimal?

## The Model

We'd like a model that takes in a 28px noisy images and outputs a prediction of the same shape. A popular choice here is an architecture called a UNet. [Originally invented for segmentation tasks in medical imagery](https://arxiv.org/abs/1505.04597), a UNet consists of a 'constricting path' through which data is compressed down and an 'expanding path' through which it expands back up to the original dimension (similar to an autoencoder) but also features skip connections that allow for information and gradients to flow across at different levels. 

Some UNets feature complex blocks at each stage, but for this toy demo we'll build a minimal example that takes in a one-channel image and passes it through three convolutional layers on the down path (the down_layers in the diagram and code) and three on the up path, with skip connections between the down and up layers. We'll use max pooling for downsampling and `nn.Upsample` for upsampling rather than relying on learnable layers like more complex UNets. Here is the rough architecture showing the number of channels in the output of each layer:

![unet_diag.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAyEAAAH3CAYAAACsFlDoAAAAAXNSR0IArs4c6QAACiJ0RVh0bXhmaWxlACUzQ214ZmlsZSUyMGhvc3QlM0QlMjJhcHAuZGlhZ3JhbXMubmV0JTIyJTIwbW9kaWZpZWQlM0QlMjIyMDIyLTExLTAyVDEwJTNBMDAlM0E1NC4wOTFaJTIyJTIwYWdlbnQlM0QlMjI1LjAlMjAoWDExJTNCJTIwTGludXglMjB4ODZfNjQpJTIwQXBwbGVXZWJLaXQlMkY1MzcuMzYlMjAoS0hUTUwlMkMlMjBsaWtlJTIwR2Vja28pJTIwQ2hyb21lJTJGMTA1LjAuMC4wJTIwU2FmYXJpJTJGNTM3LjM2JTIyJTIwZXRhZyUzRCUyMnhobW1XRVlDQWJLZEZkb1Nxa2UzJTIyJTIwdmVyc2lvbiUzRCUyMjIwLjUuMSUyMiUyMHR5cGUlM0QlMjJkZXZpY2UlMjIlM0UlM0NkaWFncmFtJTIwaWQlM0QlMjJYZks5aVFKWEllZjIwRU5pczJxWiUyMiUyMG5hbWUlM0QlMjJQYWdlLTElMjIlM0U3VnRiYjZNNEZQNDFrYVlQamNEbWxzZGVabmVsMVl3cVZhdk9QSTFjY0FnYUFsa2diZEpmdnphJTJCWUd5U3BwM1FPS3ZwUyUyQjF6am8zOW5TdkdtY0NiNWViUENxMFdYOG9FNXhQZ0pKc0p2SjBBNFBwUlFQNVJ5cFpSWmw3SUNHbVZKVnlvSTl4bkw1Z1RIVTVkWndtdWU0Sk5XZVpOdHVvVDQ3SW9jTnowYUtpcXl1ZSUyQjJMek0lMkIwOWRvUlFiaFBzWTVTYjFJVXVhQmFOR0lPem9mJTJCRXNYWWdudThHTWNaWklDUE9kMUF1VWxNOEtDWDZld0p1cUxCdldXbTV1Y0U3QkU3aXdjWCUyRnM0TXFGVmJob0RobHcyeXpTNGlXdWZ6NTglMkZmdmw2NmE1dTl3JTJCWEVLJTJCdUNlVXIlMkZtT3lTS0xHaTFYQkFFUTVHVHE2OGVLdEZMYSUyQmxRVTB5OW9jMGMwQUpJTHZxOW1LOENxeW5XUllQbzhod2clMkZMN0lHMzY5UVRMblB4RHdJYmRFc2M5SnpTVE5COWFLVnBSMiUyQkNsdzFlTE56ZjY1RWpaZ2JMcGU0cWJaRVJBeVlRVGFFVzVvWCUyQnF6JTJGM09uTjlmbCUyQkY0ck9BazVEM0ZSU09YV0hKbWx3UU44QUxvZ0d3ZjJSb3kydUxBTlB3eTRhd002THBnSlNGVDV2TFBoY0F6MzMxMEE3UGs2dWNHNEZKekJnWWhDTVptTUdTQkNjSGlXJTJGRHhPSVRKaThBWmpjMFZ3UkdqQUYzc2xoZ3BvMXdlQXdtS0t4VVBKc05LYndkWmNiQW1rOGwlMkZOdHRDVUFiWE81d0VhWTRNd3lsd3R0Uk1rTExVUEpMS1FzUU1tM0xzdk5iSXpmZ1hXUnlUVmZlazVmV1lZejIwcEwxeXpBTFRDbjhJQVMlMkZHUHJBZGVzd1JQVG5zaEUyYXJHcjJPRTZoVTd5SmhuRzRycjlUekw4NXN5TDZ0MklwZ2dITTFqUXElMkJicXZ5SkZVNFFSJTJGaHhmcVFVb0RsdDBMMzhxUVlKcGdOdmhCMzElMkJGaWJoWHdDeERsRnZVSkZEJTJGVGczelU5WGJtT0dVWlhoRm1saiUyQmdUc1FUeWVFZjdkOUVpNTh6TG9ybWNvMldXYjltUVpWbVVOVk9YNU5mdFFSWGxPcXNOb3hPc20wdVVaMm5CR0hXRHFxWmxpV1dJVTVRSjhQVVRNNTlnUUtudGNaRHNDVXo4RmhWQ3VhVnRhc2clMkJSY0VuVUw0bTYwcFpvZngzVFFPNmFSajBrcE1vVDJESVM1WXdlVUpRalo3eVc3T245TmJ3S2NWdHU5ejRLWUdaUHlVcXoyWW1mY2p1SkV0dXJETnluNXE1bEp4MVFEaGJaY3ZjNUFXTG1YM0hibzFjTUxuNTclMkJBU041Q2NWRm1GRG43YmxScFFpWDI3NEhLR0FURTNJSTdGUEVGWTIzbEhJdUJveGFoblNTZ3kzNVlUJTJCRHNVblRJVXRWU3FBQm8xbUFxTXFNUVFvQUpNRmFSMTFZb0pkZmlnOVM5blIlMkZOQ2hxU2VldVEwbllyNmNxMmFwQlJWbGVRcjZwSUNUR1ZDcEZ0MDIwdTd0cWslMkJqcCUyQmlRb1hTWVNwUUZiZ0lMWEJzbVNZT0hlbjJSbmJxUGNya29EJTJCNVVMb2lrV2pQRnhwWFJMcGNaR1FqSlI4cEdVbmtwRjVXVXZPUzFFQzNNcEdkM29aTVQwU0JSTTFYUEdNcG8yWjlRSjJ0QnByTVhwMkl5R0NxR005VG5aRE1aSHVsMm95bVNLUzl0UTRybVJNVlhlc3MwMTdsbUVFVEY2N2VCZzdoNzZwM25ITlpBdnpodWtUa3Y5OTF5V25yRWhob2RVbGtTVjFpSHJ5dXgzd2Q5WEdVZUVOZ1IlMkJBUkJzR1JYa2M5UzhFMnoyJTJGWDVobkptWUVkMkZweG04ZkFhM2p1WUllQm5TY3R3SHk5TWFCdXFnd1ZhWDRBMWhxMDJDWGdoa1BRem9JUW9pTkI2d0xOanVFQXJnTkhoZjVZSjRYQSUyRkhSNGJwaUNTTU4weUZZJTJGRkZNejNaMGRwbzUlMkIlMkIlMkJhd28lMkYlMkZ4TURXeldqSmluUDJZWXlSdkt0eFB3RHlEVmtSYWFINW5XYSUyRjIzY0Q3aDNNdHU0QVhCTFpkd0JPZnEzckkybmo5em90TTY3VGhDaDQwUDdjY0w3ak81M01RRCUyRnA5RWp3R1BnMnVTVmFSMEpHVkJaMFAxODJSRERXMExONUNzOVphanhodlAlMkJhTmJlWlBMWTIzWTFZTXB6TnF2VEE3ZGJFTHpTTGlmd0N6cjc5VG5MciUyQmhlWkxjZjB6VzAza1R5SW9BanJ1OGJwNmt2a0xGOGtWJTJGYVVFNmNZNXF1c3M3a1BmejR4NGt6WGZ4RWpTJTJGcTdRYnpkcVp5czZCZG5uTjdYelhlMTBnOXFlR01YV2pCUGo1eG1hcHNpJTJCeW5VVjR6MFE4ZWphb0NyRnpSNDVkNGZxRmRVT2xTJTJCQ1Z1RWNOZGxUZjcxRCUyQnVaUHVDc3plaklzQTZaMnNjVXdHYlpQUHFxekdtTWk0NGFNcTAzRWdEQW1Ja2FBdG9yWWlnclV1eGRzJTJGT0RDMmJzcyUyRlI1WVg1dzAyUE03VDVBYSUyQkFYbk1HJTJGRWplc2M3ekwxdDd2VUVaM0RQOUE1b2xQNmhuNEpISVR2OVEwdGZMdlFtVHJLbjJBZjJWWDBtJTJGNnYlMkJZcSUyRlglMkY2dHpqTGhIMm9VOGU0VERmejhIdyUzRCUzRCUzQyUyRmRpYWdyYW0lM0UlM0MlMkZteGZpbGUlM0UIB+IBAAAgAElEQVR4XuydB5gVRfa3j4AkiUMWhqQioCQTIEFQFNMSxLSIillxRdeIgqtr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)


This is what that looks like in code:

```python
class BasicUNet(nn.Module):
    """A minimal UNet implementation."""

    def __init__(self, in_channels=1, out_channels=1):
        super().__init__()
        self.down_layers = torch.nn.ModuleList(
            [
                nn.Conv2d(in_channels, 32, kernel_size=5, padding=2),
                nn.Conv2d(32, 64, kernel_size=5, padding=2),
                nn.Conv2d(64, 64, kernel_size=5, padding=2),
            ]
        )
        self.up_layers = torch.nn.ModuleList(
            [
                nn.Conv2d(64, 64, kernel_size=5, padding=2),
                nn.Conv2d(64, 32, kernel_size=5, padding=2),
                nn.Conv2d(32, out_channels, kernel_size=5, padding=2),
            ]
        )
        self.act = nn.SiLU()  # The activation function
        self.downscale = nn.MaxPool2d(2)
        self.upscale = nn.Upsample(scale_factor=2)

    def forward(self, x):
        h = []
        for i, l in enumerate(self.down_layers):
            x = self.act(l(x))  # Through the layer and the activation function
            if i < 2:  # For all but the third (final) down layer:
                h.append(x)  # Storing output for skip connection
                x = self.downscale(x)  # Downscale ready for the next layer

        for i, l in enumerate(self.up_layers):
            if i > 0:  # For all except the first up layer
                x = self.upscale(x)  # Upscale
                x += h.pop()  # Fetching stored output (skip connection)
            x = self.act(l(x))  # Through the layer and the activation function

        return x
```

We can verify that the output shape is the same as the input, as we expect:

```python
net = BasicUNet()
x = torch.rand(8, 1, 28, 28)
net(x).shape
```

This network has just over 300,000 parameters:

```python
sum([p.numel() for p in net.parameters()])
```

You can explore changing the number of channels in each layer or swapping in different architectures if you want.

## Training the network

So what should the model do, exactly? Again, there are various takes on this but for this demo let's pick a simple framing: given a corrupted input noisy_x the model should output its best guess for what the original x looks like. We will compare this to the actual value via the mean squared error.

We can now have a go at training the network. 
- Get a batch of data
- Corrupt it by random amounts
- Feed it through the model
- Compare the model predictions with the clean images to calculate our loss
- Update the model's parameters accordingly.

Feel free to modify this and see if you can get it working better!

```python
>>> # Dataloader (you can mess with batch size)
>>> batch_size = 128
>>> train_dataloader = DataLoader(dataset, batch_size=batch_size, shuffle=True)

>>> # How many runs through the data should we do?
>>> n_epochs = 3

>>> # Create the network
>>> net = BasicUNet()
>>> net.to(device)

>>> # Our loss function
>>> loss_fn = nn.MSELoss()

>>> # The optimizer
>>> opt = torch.optim.Adam(net.parameters(), lr=1e-3)

>>> # Keeping a record of the losses for later viewing
>>> losses = []

>>> # The training loop
>>> for epoch in range(n_epochs):

...     for x, y in train_dataloader:

...         # Get some data and prepare the corrupted version
...         x = x.to(device)  # Data on the GPU
...         noise_amount = torch.rand(x.shape[0]).to(device)  # Pick random noise amounts
...         noisy_x = corrupt(x, noise_amount)  # Create our noisy x

...         # Get the model prediction
...         pred = net(noisy_x)

...         # Calculate the loss
...         loss = loss_fn(pred, x)  # How close is the output to the true 'clean' x?

...         # Backprop and update the params:
...         opt.zero_grad()
...         loss.backward()
...         opt.step()

...         # Store the loss for later
...         losses.append(loss.item())

...     # Print our the average of the loss values for this epoch:
...     avg_loss = sum(losses[-len(train_dataloader) :]) / len(train_dataloader)
...     print(f"Finished epoch {epoch}. Average loss for this epoch: {avg_loss:05f}")

>>> # View the loss curve
>>> plt.plot(losses)
>>> plt.ylim(0, 0.1)
```

<pre>
Finished epoch 0. Average loss for this epoch: 0.026736
Finished epoch 1. Average loss for this epoch: 0.020692
Finished epoch 2. Average loss for this epoch: 0.018887
</pre>

We can try to see what the model predictions look like by grabbing a batch of data, corrupting it by different amounts and then seeing the models predictions:

```python
# @markdown Visualizing model predictions on noisy inputs:

# Fetch some data
x, y = next(iter(train_dataloader))
x = x[:8]  # Only using the first 8 for easy plotting

# Corrupt with a range of amounts
amount = torch.linspace(0, 1, x.shape[0])  # Left to right -> more corruption
noised_x = corrupt(x, amount)

# Get the model predictions
with torch.no_grad():
    preds = net(noised_x.to(device)).detach().cpu()

# Plot
fig, axs = plt.subplots(3, 1, figsize=(12, 7))
axs[0].set_title("Input data")
axs[0].imshow(torchvision.utils.make_grid(x)[0].clip(0, 1), cmap="Greys")
axs[1].set_title("Corrupted data")
axs[1].imshow(torchvision.utils.make_grid(noised_x)[0].clip(0, 1), cmap="Greys")
axs[2].set_title("Network Predictions")
axs[2].imshow(torchvision.utils.make_grid(preds)[0].clip(0, 1), cmap="Greys")
```

You can see that for the lower amounts the predictions are pretty good! But as the level gets very high there is less for the model to work with, and by the time we get to amount=1 it outputs a blurry mess close to the mean of the dataset to try and hedge its bets on what the output might look like...

## Sampling

If our predictions at high noise levels aren't very good, how do we generate images?

Well, what if we start from random noise, look at the model predictions but then only move a small amount towards that prediction - say, 20% of the way there. Now we have a very noisy image in which there is perhaps a hint of structure, which we can feed into the model to get a new prediction. The hope is that this new prediction is slightly better than the first one (since our starting point is slightly less noisy) and so we can take another small step with this new, better prediction.

Repeat a few times and (if all goes well) we get an image out! Here is that process illustrated over just 5 steps, visualizing the model input (left) and the predicted denoised images (right) at each stage. Note that even though the model predicts the denoised image even at step 1, we only move x part of the way there. Over a few steps the structures appear and are refined, until we get our final outputs.

```python
# @markdown Sampling strategy: Break the process into 5 steps and move 1/5'th of the way there each time:
n_steps = 5
x = torch.rand(8, 1, 28, 28).to(device)  # Start from random
step_history = [x.detach().cpu()]
pred_output_history = []

for i in range(n_steps):
    with torch.no_grad():  # No need to track gradients during inference
        pred = net(x)  # Predict the denoised x0
    pred_output_history.append(pred.detach().cpu())  # Store model output for plotting
    mix_factor = 1 / (n_steps - i)  # How much we move towards the prediction
    x = x * (1 - mix_factor) + pred * mix_factor  # Move part of the way there
    step_history.append(x.detach().cpu())  # Store step for plotting

fig, axs = plt.subplots(n_steps, 2, figsize=(9, 4), sharex=True)
axs[0, 0].set_title("x (model input)")
axs[0, 1].set_title("model prediction")
for i in range(n_steps):
    axs[i, 0].imshow(torchvision.utils.make_grid(step_history[i])[0].clip(0, 1), cmap="Greys")
    axs[i, 1].imshow(torchvision.utils.make_grid(pred_output_history[i])[0].clip(0, 1), cmap="Greys")
```

We can split the process up into more steps, and hope for better images that way:

```python
# @markdown Showing more results, using 40 sampling steps
n_steps = 40
x = torch.rand(64, 1, 28, 28).to(device)
for i in range(n_steps):
    noise_amount = torch.ones((x.shape[0],)).to(device) * (1 - (i / n_steps))  # Starting high going low
    with torch.no_grad():
        pred = net(x)
    mix_factor = 1 / (n_steps - i)
    x = x * (1 - mix_factor) + pred * mix_factor
fig, ax = plt.subplots(1, 1, figsize=(12, 12))
ax.imshow(torchvision.utils.make_grid(x.detach().cpu(), nrow=8)[0].clip(0, 1), cmap="Greys")
```

Not great, but there are some recognizable digits there! You can experiment with training for longer (say, 10 or 20 epochs) and tweaking model config, learning rate, optimizer and so on. Also, don't forget that fashionMNIST is a one-line replacement if you want a slightly harder dataset to try.

## Comparison To DDPM

In this section we'll take a look at how our toy implementation differs from the approach used in the other notebook ([Introduction to Diffusers](https://github.com/huggingface/diffusion-models-class/blob/main/unit1/01_introduction_to_diffusers.ipynb)), which is based on the DDPM paper.

We'll see that


*   The diffusers `UNet2DModel` is a bit more advanced than our BasicUNet
*   The corruption process in handled differently
*   The training objective is different, involving predicting the noise rather than the denoised image
*   The model is conditioned on the amount of noise present via timestep conditioning, where t is passed as an additional argument to the forward method.
*   There are a number of different sampling strategies available, which should work better than our simplistic version above.

There have been a number of improvements suggested since the DDPM paper came out, but this example is hopefully instructive as to the different available design decisions. Once you've read through this, you may enjoy diving into the paper ['Elucidating the Design Space of Diffusion-Based Generative Models'](https://arxiv.org/abs/2206.00364) which explores all of these components in some detail and makes new recommendations for how to get the best performance. 

If all of this is too technical or intimidating, don't worry! Feel free to skip the rest of this notebook or save it for a rainy day. 




### The UNet

The diffusers UNet2DModel model has a number of improvements over our basic UNet above:

*   GroupNorm applies group normalization to the inputs of each block
*   Dropout layers for smoother training
*   Multiple resnet layers per block (if layers_per_block isn't set to 1)
*   Attention (usually used only at lower resolution blocks)
*   Conditioning on the timestep. 
*   Downsampling and upsampling blocks with learnable parameters

Let's create and inspect a UNet2DModel:



```python
>>> model = UNet2DModel(
...     sample_size=28,  # the target image resolution
...     in_channels=1,  # the number of input channels, 3 for RGB images
...     out_channels=1,  # the number of output channels
...     layers_per_block=2,  # how many ResNet layers to use per UNet block
...     block_out_channels=(32, 64, 64),  # Roughly matching our basic unet example
...     down_block_types=(
...         "DownBlock2D",  # a regular ResNet downsampling block
...         "AttnDownBlock2D",  # a ResNet downsampling block with spatial self-attention
...         "AttnDownBlock2D",
...     ),
...     up_block_types=(
...         "AttnUpBlock2D",
...         "AttnUpBlock2D",  # a ResNet upsampling block with spatial self-attention
...         "UpBlock2D",  # a regular ResNet upsampling block
...     ),
... )
>>> print(model)
```

<pre>
UNet2DModel(
  (conv_in): Conv2d(1, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (time_proj): Timesteps()
  (time_embedding): TimestepEmbedding(
    (linear_1): Linear(in_features=32, out_features=128, bias=True)
    (act): SiLU()
    (linear_2): Linear(in_features=128, out_features=128, bias=True)
  )
  (down_blocks): ModuleList(
    (0): DownBlock2D(
      (resnets): ModuleList(
        (0): ResnetBlock2D(
          (norm1): GroupNorm(32, 32, eps=1e-05, affine=True)
          (conv1): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (time_emb_proj): Linear(in_features=128, out_features=32, bias=True)
          (norm2): GroupNorm(32, 32, eps=1e-05, affine=True)
          (dropout): Dropout(p=0.0, inplace=False)
          (conv2): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (nonlinearity): SiLU()
        )
        (1): ResnetBlock2D(
          (norm1): GroupNorm(32, 32, eps=1e-05, affine=True)
          (conv1): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (time_emb_proj): Linear(in_features=128, out_features=32, bias=True)
          (norm2): GroupNorm(32, 32, eps=1e-05, affine=True)
          (dropout): Dropout(p=0.0, inplace=False)
          (conv2): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (nonlinearity): SiLU()
        )
      )
      (downsamplers): ModuleList(
        (0): Downsample2D(
          (conv): Conv2d(32, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))
        )
      )
    )
    (1): AttnDownBlock2D(
      (attentions): ModuleList(
        (0): AttentionBlock(
          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)
          (query): Linear(in_features=64, out_features=64, bias=True)
          (key): Linear(in_features=64, out_features=64, bias=True)
          (value): Linear(in_features=64, out_features=64, bias=True)
          (proj_attn): Linear(in_features=64, out_features=64, bias=True)
        )
        (1): AttentionBlock(
          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)
          (query): Linear(in_features=64, out_features=64, bias=True)
          (key): Linear(in_features=64, out_features=64, bias=True)
          (value): Linear(in_features=64, out_features=64, bias=True)
          (proj_attn): Linear(in_features=64, out_features=64, bias=True)
        )
      )
      (resnets): ModuleList(
        (0): ResnetBlock2D(
          (norm1): GroupNorm(32, 32, eps=1e-05, affine=True)
          (conv1): Conv2d(32, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)
          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)
          (dropout): Dropout(p=0.0, inplace=False)
          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (nonlinearity): SiLU()
          (conv_shortcut): Conv2d(32, 64, kernel_size=(1, 1), stride=(1, 1))
        )
        (1): ResnetBlock2D(
          (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)
          (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)
          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)
          (dropout): Dropout(p=0.0, inplace=False)
          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (nonlinearity): SiLU()
        )
      )
      (downsamplers): ModuleList(
        (0): Downsample2D(
          (conv): Conv2d(64, 64, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))
        )
      )
    )
    (2): AttnDownBlock2D(
      (attentions): ModuleList(
        (0): AttentionBlock(
          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)
          (query): Linear(in_features=64, out_features=64, bias=True)
          (key): Linear(in_features=64, out_features=64, bias=True)
          (value): Linear(in_features=64, out_features=64, bias=True)
          (proj_attn): Linear(in_features=64, out_features=64, bias=True)
        )
        (1): AttentionBlock(
          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)
          (query): Linear(in_features=64, out_features=64, bias=True)
          (key): Linear(in_features=64, out_features=64, bias=True)
          (value): Linear(in_features=64, out_features=64, bias=True)
          (proj_attn): Linear(in_features=64, out_features=64, bias=True)
        )
      )
      (resnets): ModuleList(
        (0): ResnetBlock2D(
          (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)
          (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)
          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)
          (dropout): Dropout(p=0.0, inplace=False)
          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (nonlinearity): SiLU()
        )
        (1): ResnetBlock2D(
          (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)
          (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)
          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)
          (dropout): Dropout(p=0.0, inplace=False)
          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (nonlinearity): SiLU()
        )
      )
    )
  )
  (up_blocks): ModuleList(
    (0): AttnUpBlock2D(
      (attentions): ModuleList(
        (0): AttentionBlock(
          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)
          (query): Linear(in_features=64, out_features=64, bias=True)
          (key): Linear(in_features=64, out_features=64, bias=True)
          (value): Linear(in_features=64, out_features=64, bias=True)
          (proj_attn): Linear(in_features=64, out_features=64, bias=True)
        )
        (1): AttentionBlock(
          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)
          (query): Linear(in_features=64, out_features=64, bias=True)
          (key): Linear(in_features=64, out_features=64, bias=True)
          (value): Linear(in_features=64, out_features=64, bias=True)
          (proj_attn): Linear(in_features=64, out_features=64, bias=True)
        )
        (2): AttentionBlock(
          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)
          (query): Linear(in_features=64, out_features=64, bias=True)
          (key): Linear(in_features=64, out_features=64, bias=True)
          (value): Linear(in_features=64, out_features=64, bias=True)
          (proj_attn): Linear(in_features=64, out_features=64, bias=True)
        )
      )
      (resnets): ModuleList(
        (0): ResnetBlock2D(
          (norm1): GroupNorm(32, 128, eps=1e-05, affine=True)
          (conv1): Conv2d(128, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)
          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)
          (dropout): Dropout(p=0.0, inplace=False)
          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (nonlinearity): SiLU()
          (conv_shortcut): Conv2d(128, 64, kernel_size=(1, 1), stride=(1, 1))
        )
        (1): ResnetBlock2D(
          (norm1): GroupNorm(32, 128, eps=1e-05, affine=True)
          (conv1): Conv2d(128, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)
          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)
          (dropout): Dropout(p=0.0, inplace=False)
          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (nonlinearity): SiLU()
          (conv_shortcut): Conv2d(128, 64, kernel_size=(1, 1), stride=(1, 1))
        )
        (2): ResnetBlock2D(
          (norm1): GroupNorm(32, 128, eps=1e-05, affine=True)
          (conv1): Conv2d(128, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)
          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)
          (dropout): Dropout(p=0.0, inplace=False)
          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (nonlinearity): SiLU()
          (conv_shortcut): Conv2d(128, 64, kernel_size=(1, 1), stride=(1, 1))
        )
      )
      (upsamplers): ModuleList(
        (0): Upsample2D(
          (conv): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        )
      )
    )
    (1): AttnUpBlock2D(
      (attentions): ModuleList(
        (0): AttentionBlock(
          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)
          (query): Linear(in_features=64, out_features=64, bias=True)
          (key): Linear(in_features=64, out_features=64, bias=True)
          (value): Linear(in_features=64, out_features=64, bias=True)
          (proj_attn): Linear(in_features=64, out_features=64, bias=True)
        )
        (1): AttentionBlock(
          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)
          (query): Linear(in_features=64, out_features=64, bias=True)
          (key): Linear(in_features=64, out_features=64, bias=True)
          (value): Linear(in_features=64, out_features=64, bias=True)
          (proj_attn): Linear(in_features=64, out_features=64, bias=True)
        )
        (2): AttentionBlock(
          (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)
          (query): Linear(in_features=64, out_features=64, bias=True)
          (key): Linear(in_features=64, out_features=64, bias=True)
          (value): Linear(in_features=64, out_features=64, bias=True)
          (proj_attn): Linear(in_features=64, out_features=64, bias=True)
        )
      )
      (resnets): ModuleList(
        (0): ResnetBlock2D(
          (norm1): GroupNorm(32, 128, eps=1e-05, affine=True)
          (conv1): Conv2d(128, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)
          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)
          (dropout): Dropout(p=0.0, inplace=False)
          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (nonlinearity): SiLU()
          (conv_shortcut): Conv2d(128, 64, kernel_size=(1, 1), stride=(1, 1))
        )
        (1): ResnetBlock2D(
          (norm1): GroupNorm(32, 128, eps=1e-05, affine=True)
          (conv1): Conv2d(128, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)
          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)
          (dropout): Dropout(p=0.0, inplace=False)
          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (nonlinearity): SiLU()
          (conv_shortcut): Conv2d(128, 64, kernel_size=(1, 1), stride=(1, 1))
        )
        (2): ResnetBlock2D(
          (norm1): GroupNorm(32, 96, eps=1e-05, affine=True)
          (conv1): Conv2d(96, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)
          (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)
          (dropout): Dropout(p=0.0, inplace=False)
          (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (nonlinearity): SiLU()
          (conv_shortcut): Conv2d(96, 64, kernel_size=(1, 1), stride=(1, 1))
        )
      )
      (upsamplers): ModuleList(
        (0): Upsample2D(
          (conv): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        )
      )
    )
    (2): UpBlock2D(
      (resnets): ModuleList(
        (0): ResnetBlock2D(
          (norm1): GroupNorm(32, 96, eps=1e-05, affine=True)
          (conv1): Conv2d(96, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (time_emb_proj): Linear(in_features=128, out_features=32, bias=True)
          (norm2): GroupNorm(32, 32, eps=1e-05, affine=True)
          (dropout): Dropout(p=0.0, inplace=False)
          (conv2): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (nonlinearity): SiLU()
          (conv_shortcut): Conv2d(96, 32, kernel_size=(1, 1), stride=(1, 1))
        )
        (1): ResnetBlock2D(
          (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)
          (conv1): Conv2d(64, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (time_emb_proj): Linear(in_features=128, out_features=32, bias=True)
          (norm2): GroupNorm(32, 32, eps=1e-05, affine=True)
          (dropout): Dropout(p=0.0, inplace=False)
          (conv2): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (nonlinearity): SiLU()
          (conv_shortcut): Conv2d(64, 32, kernel_size=(1, 1), stride=(1, 1))
        )
        (2): ResnetBlock2D(
          (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)
          (conv1): Conv2d(64, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (time_emb_proj): Linear(in_features=128, out_features=32, bias=True)
          (norm2): GroupNorm(32, 32, eps=1e-05, affine=True)
          (dropout): Dropout(p=0.0, inplace=False)
          (conv2): Conv2d(32, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
          (nonlinearity): SiLU()
          (conv_shortcut): Conv2d(64, 32, kernel_size=(1, 1), stride=(1, 1))
        )
      )
    )
  )
  (mid_block): UNetMidBlock2D(
    (attentions): ModuleList(
      (0): AttentionBlock(
        (group_norm): GroupNorm(32, 64, eps=1e-05, affine=True)
        (query): Linear(in_features=64, out_features=64, bias=True)
        (key): Linear(in_features=64, out_features=64, bias=True)
        (value): Linear(in_features=64, out_features=64, bias=True)
        (proj_attn): Linear(in_features=64, out_features=64, bias=True)
      )
    )
    (resnets): ModuleList(
      (0): ResnetBlock2D(
        (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)
        (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)
        (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)
        (dropout): Dropout(p=0.0, inplace=False)
        (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (nonlinearity): SiLU()
      )
      (1): ResnetBlock2D(
        (norm1): GroupNorm(32, 64, eps=1e-05, affine=True)
        (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (time_emb_proj): Linear(in_features=128, out_features=64, bias=True)
        (norm2): GroupNorm(32, 64, eps=1e-05, affine=True)
        (dropout): Dropout(p=0.0, inplace=False)
        (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
        (nonlinearity): SiLU()
      )
    )
  )
  (conv_norm_out): GroupNorm(32, 32, eps=1e-05, affine=True)
  (conv_act): SiLU()
  (conv_out): Conv2d(32, 1, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
)
</pre>

As you can see, a little more going on! It also has significantly more parameters than our BasicUNet:

```python
sum([p.numel() for p in model.parameters()])  # 1.7M vs the ~309k parameters of the BasicUNet
```

We can replicate the training shown above using this model in place of our original one. We need to pass both x and timestep to the model (here I always pass t=0 to show that it works without this timestep conditioning and to keep the sampling code easy, but you can also try feeding in `(amount*1000)` to get a timestep equivalent from the corruption amount). Lines changed are shown with `#<<<` if you want to inspect the code.

```python
>>> # @markdown Trying UNet2DModel instead of BasicUNet:

>>> # Dataloader (you can mess with batch size)
>>> batch_size = 128
>>> train_dataloader = DataLoader(dataset, batch_size=batch_size, shuffle=True)

>>> # How many runs through the data should we do?
>>> n_epochs = 3

>>> # Create the network
>>> net = UNet2DModel(
...     sample_size=28,  # the target image resolution
...     in_channels=1,  # the number of input channels, 3 for RGB images
...     out_channels=1,  # the number of output channels
...     layers_per_block=2,  # how many ResNet layers to use per UNet block
...     block_out_channels=(32, 64, 64),  # Roughly matching our basic unet example
...     down_block_types=(
...         "DownBlock2D",  # a regular ResNet downsampling block
...         "AttnDownBlock2D",  # a ResNet downsampling block with spatial self-attention
...         "AttnDownBlock2D",
...     ),
...     up_block_types=(
...         "AttnUpBlock2D",
...         "AttnUpBlock2D",  # a ResNet upsampling block with spatial self-attention
...         "UpBlock2D",  # a regular ResNet upsampling block
...     ),
... )  # <<<
>>> net.to(device)

>>> # Our loss finction
>>> loss_fn = nn.MSELoss()

>>> # The optimizer
>>> opt = torch.optim.Adam(net.parameters(), lr=1e-3)

>>> # Keeping a record of the losses for later viewing
>>> losses = []

>>> # The training loop
>>> for epoch in range(n_epochs):

...     for x, y in train_dataloader:

...         # Get some data and prepare the corrupted version
...         x = x.to(device)  # Data on the GPU
...         noise_amount = torch.rand(x.shape[0]).to(device)  # Pick random noise amounts
...         noisy_x = corrupt(x, noise_amount)  # Create our noisy x

...         # Get the model prediction
...         pred = net(noisy_x, 0).sample  # <<< Using timestep 0 always, adding .sample

...         # Calculate the loss
...         loss = loss_fn(pred, x)  # How close is the output to the true 'clean' x?

...         # Backprop and update the params:
...         opt.zero_grad()
...         loss.backward()
...         opt.step()

...         # Store the loss for later
...         losses.append(loss.item())

...     # Print our the average of the loss values for this epoch:
...     avg_loss = sum(losses[-len(train_dataloader) :]) / len(train_dataloader)
...     print(f"Finished epoch {epoch}. Average loss for this epoch: {avg_loss:05f}")

>>> # Plot losses and some samples
>>> fig, axs = plt.subplots(1, 2, figsize=(12, 5))

>>> # Losses
>>> axs[0].plot(losses)
>>> axs[0].set_ylim(0, 0.1)
>>> axs[0].set_title("Loss over time")

>>> # Samples
>>> n_steps = 40
>>> x = torch.rand(64, 1, 28, 28).to(device)
>>> for i in range(n_steps):
...     noise_amount = torch.ones((x.shape[0],)).to(device) * (1 - (i / n_steps))  # Starting high going low
...     with torch.no_grad():
...         pred = net(x, 0).sample
...     mix_factor = 1 / (n_steps - i)
...     x = x * (1 - mix_factor) + pred * mix_factor

>>> axs[1].imshow(torchvision.utils.make_grid(x.detach().cpu(), nrow=8)[0].clip(0, 1), cmap="Greys")
>>> axs[1].set_title("Generated Samples")
```

<pre>
Finished epoch 0. Average loss for this epoch: 0.018925
Finished epoch 1. Average loss for this epoch: 0.012785
Finished epoch 2. Average loss for this epoch: 0.011694
</pre>

This looks quite a bit better than our first set of results! You can explore tweaking the unet configuration or training for longer to get even better performance. 

### The Corruption Process

The DDPM paper describes a corruption process that adds a small amount of noise for every 'timestep'. Given $x_{t-1}$ for some timestep, we can get the next (slightly more noisy) version $x_t$ with:<br><br>

$q(\mathbf{x}_t \vert \mathbf{x}_{t-1}) = \mathcal{N}(\mathbf{x}_t; \sqrt{1 - \beta_t} \mathbf{x}_{t-1}, \beta_t\mathbf{I}) \quad
q(\mathbf{x}_{1:T} \vert \mathbf{x}_0) = \prod^T_{t=1} q(\mathbf{x}_t \vert \mathbf{x}_{t-1})$<br><br>


That is, we take $x_{t-1}$, scale it by $\sqrt{1 - \beta_t}$ and add noise scaled by $\beta_t$. This $\beta$ is defined for every t according to some schedule, and determines how much noise is added per timestep. Now, we don't necessarily want to do this operation 500 times to get $x_{500}$ so we have another formula to get $x_t$ for any t given $x_0$: <br><br>

$\begin{aligned}
q(\mathbf{x}_t \vert \mathbf{x}_0) &= \mathcal{N}(\mathbf{x}_t; \sqrt{\bar{\alpha}_t} \mathbf{x}_0, \sqrt{(1 - \bar{\alpha}_t)} \mathbf{I})
\end{aligned}$ where $\bar{\alpha}_t = \prod_{i=1}^T \alpha_i$ and $\alpha_i = 1-\beta_i$<br><br>

The maths notation always looks scary! Luckily the scheduler handles all that for us (uncomment the next cell to check out the code). We can plot $\sqrt{\bar{\alpha}_t}$ (labelled as `sqrt_alpha_prod`) and $\sqrt{(1 - \bar{\alpha}_t)}$ (labelled as `sqrt_one_minus_alpha_prod`) to view how the input (x) and the noise are scaled and mixed across different timesteps:


```python
# ??noise_scheduler.add_noise
```

```python
noise_scheduler = DDPMScheduler(num_train_timesteps=1000)
plt.plot(noise_scheduler.alphas_cumprod.cpu() ** 0.5, label=r"${\sqrt{\bar{\alpha}_t}}$")
plt.plot((1 - noise_scheduler.alphas_cumprod.cpu()) ** 0.5, label=r"$\sqrt{(1 - \bar{\alpha}_t)}$")
plt.legend(fontsize="x-large")
```

Initially, the noisy x is mostly x (sqrt_alpha_prod ~= 1) but over time the contribution of x drops and the noise component increases. Unlike our linear mix of x and noise according to `amount`, this one gets noisy relatively quickly. We can visualize this on some data:

```python
>>> # @markdown visualize the DDPM noising process for different timesteps:

>>> # Noise a batch of images to view the effect
>>> fig, axs = plt.subplots(3, 1, figsize=(16, 10))
>>> xb, yb = next(iter(train_dataloader))
>>> xb = xb.to(device)[:8]
>>> xb = xb * 2.0 - 1.0  # Map to (-1, 1)
>>> print("X shape", xb.shape)

>>> # Show clean inputs
>>> axs[0].imshow(torchvision.utils.make_grid(xb[:8])[0].detach().cpu(), cmap="Greys")
>>> axs[0].set_title("Clean X")

>>> # Add noise with scheduler
>>> timesteps = torch.linspace(0, 999, 8).long().to(device)
>>> noise = torch.randn_like(xb)  # << NB: randn not rand
>>> noisy_xb = noise_scheduler.add_noise(xb, noise, timesteps)
>>> print("Noisy X shape", noisy_xb.shape)

>>> # Show noisy version (with and without clipping)
>>> axs[1].imshow(torchvision.utils.make_grid(noisy_xb[:8])[0].detach().cpu().clip(-1, 1), cmap="Greys")
>>> axs[1].set_title("Noisy X (clipped to (-1, 1)")
>>> axs[2].imshow(torchvision.utils.make_grid(noisy_xb[:8])[0].detach().cpu(), cmap="Greys")
>>> axs[2].set_title("Noisy X")
```

<pre>
X shape torch.Size([8, 1, 28, 28])
Noisy X shape torch.Size([8, 1, 28, 28])
</pre>

Another dynamic at play: the DDPM version adds noise drawn from a Gaussian distribution (mean 0, s.d. 1 from torch.randn) rather than the uniform noise between 0 and 1 (from torch.rand) we used in our original `corrupt` function. In general, it makes sense to normalize the training data as well. In the other notebook, you'll see `Normalize(0.5, 0.5)` in the list of transforms, which maps the image data form (0, 1) to (-1, 1) and is 'good enough' for our purposes. We didn't do that for this notebook, but the visualization cell above adds it in for more accurate scaling and visualization.

### Training Objective

In our toy example, we had the model try to predict the denoised image. In DDPM and many other diffusion model implementations, the model predicts the noise used in the corruption process (before scaling, so unit variance noise). In code, it looks something like:

```python
noise = torch.randn_like(xb) # << NB: randn not rand
noisy_x = noise_scheduler.add_noise(x, noise, timesteps)
model_prediction = model(noisy_x, timesteps).sample
loss = mse_loss(model_prediction, noise) # noise as the target
```

You may think that predicting the noise (from which we can derive what the denoised image looks like) is equivalent to just predicting the denoised image directly. So why favour one over the other - is it just for mathematical convenience?

It turns out there's another subtlety here. We compute the loss across different (randomly chosen) timesteps during training. These different objectives will lead to different 'implicit weighting' of these losses, where predicting the noise puts more weight on lower noise levels. You can pick more complex objectives to change this 'implicit loss weighting'. Or perhaps you choose a noise schedule that will result in more examples at a higher noise level. Perhaps you have the model predict a 'velocity' v which we define as being a combination of both the image and the noise dependent on the noise level (see 'PROGRESSIVE DISTILLATION FOR FAST SAMPLING OF DIFFUSION MODELS'). Perhaps you have the model predict the noise but then scale the loss by some factor dependent on the amount of noise based on a bit of theory (see 'Perception Prioritized Training of Diffusion Models') or based on experiments trying to see what noise levels are most informative to the model (see 'Elucidating the Design Space of Diffusion-Based Generative Models'). TL;DR: choosing the objective has an effect on model performance, and research in ongoing into what the 'best' option is.

At the moment, predicting the noise (epsilon or eps you'll see in some places) is the favoured approach but over time we will likely see other objectives supported in the library and used in different situations. 



### Timestep Conditioning

The UNet2DModel takes in both x and timestep. The latter is turned into an embedding and fed into the model in a number of places. 

The theory behind this is that by giving the model information about what the noise level is, it can better perform its task. While it is possible to train a model without this timestep conditioning, it does seem to help performance in some cases and most implementations include it, at least in the current literature. 

### Sampling

Given a model that estimates the noise present in a noisy input (or predicts the denoised version), how do we produce new images?

We could feed in pure noise, and hope that the model predicts a good image as the denoised version in one step. However, as we saw in the experiments above, this doesn't usually work well. So, instead, we take a number of smaller steps based on the model prediction, iteratively removing a little bit of the noise at a time.

Exactly how we take these steps depends on the sampling method used. We won't go into the theory too deeply, but some key design questions are:
- How large of a step should you take? In other words, what 'noise schedule' should you follow?
- Do you use only the model's current prediction to inform the update step (like DDPM, DDIM and many others)? Do you evaluate the model several times to estimate higher-order gradients for a larger, more accurate step (higher-order methods and some discrete ODE solvers)? Or do you keep a history of past predictions to try and better inform the current update step (linear multi-step and ancestral samplers)? 
- Do you add in additional noise (sometimes called churn) to add more stochasticity (randomness) to the sampling process, or do you keep it completely deterministic? Many samplers control this with a parameter (such as 'eta' for DDIM samplers) so that the user can choose.

Research on sampling methods for diffusion models is rapidly evolving, and more and more methods for finding good solutions in fewer steps are being proposed. The brave and curious might find it interesting to browse through the code of the different implementations available in the diffusers library [here](https://github.com/huggingface/diffusers/tree/main/src/diffusers/schedulers) or check out the [docs](https://huggingface.co/docs/diffusers/api/schedulers/overview) which often link to the relevant papers.

## Conclusions

Hopefully this has been a helpful way to look at diffusion models from a slightly different angle. 

This notebook was written for this Hugging Face course by Jonathan Whitaker, and overlaps with a [version included in his own course](https://johnowhitaker.github.io/tglcourse/dm1.html), 'The Generative Landscape'. Check that out if you'd like to see this basic example extended with noise and class conditioning. Questions or bugs can be communicated through GitHub issues or via Discord. You are also welcome to reach out via Twitter [@johnowhitaker](https://twitter.com/johnowhitaker).